#	   all the missing samples from the whole dataset.
#	   Default is "T".
print("HELLO!")
x <- c(x)
y <- c(y)
z <- as.data.frame(z, check.names = FALSE)
print(head(x))
print(head(y))
print(head(z))
useOk <- TRUE
methodOk <- TRUE
# print the method
if (gregexpr("p", calc_method)[[1]][1] == 1){
p.method <- "Pearson"
} else if (gregexpr("s", calc_method)[[1]][1] == 1){
p.method <- "Spearman"
}else if (gregexpr("k", calc_method)[[1]][1] == 1){
p.method <- "Kendall"
}else{
message("\'method\' should be \"pearson\" or \"spearman\" or \"kendall\"!\n")
methodOk <- FALSE
}
if(methodOk)
{
if (use == "mat") {
p.use <- "Var-Cov matrix"
pcor <- pcor.mat(x, y, z, cor_method = calc_method, na.rm = na.rm)
} else if (use == "rec") {
p.use <- "Recursive formula"
pcor <- pcor.rec(x, y, z, cor_method = calc_method, na.rm = na.rm)
} else {
message("\'use\' should be either \"rec\" or \"mat\"!\n")
useOk <- FALSE
}
}
if(useOk && methodOk)
{
# sample number
n <- dim(na.omit(data.frame(x, y, z, check.names = FALSE)))[1]
# given variables' number
gn <- dim(z)[2]
if (p.method == "Kendall"){
statistic <- pcor / sqrt(2 * (2 * (n - gn) + 5) / (9 * (n - gn) *
(n - 1 - gn)))
p.value <- 2 * pnorm(-abs(statistic))
} else {
val_to_sqrt_l <- n - 2 - gn
val_to_sqrt_r <- 1 - pcor ^ 2
statistic <- pcor * sqrt(val_to_sqrt_l / val_to_sqrt_r)
p.value <- 2 * pnorm(-abs(statistic))
}
#data.frame(estimate = pcor, p.value = p.value, statistic = statistic,
#           n = n, gn = gn, Method = p.method, Use = p.use,
#           check.names = FALSE)
data.frame(estimate = pcor, p.value = p.value)
}
}
map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s"))
pcor.test2 <- function(y, x, z, use = "mat", calc_method ="p", na.rm = TRUE) {
# The partial correlation coefficient between x and y given z
#
# pcor.test is free and comes with ABSOLUTELY NO WARRANTY.
#
# x and y should be vectors
#
# z can be either a vector or a matrix
#
# use: There are two methods to calculate the partial correlation coefficient
#	 One is by using variance-covariance matrix ("mat") and the other is by
# using recursive formula ("rec").
#	 Default is "mat".
#
# method: There are three ways to calculate the correlation coefficient,
#	which are Pearson's ("p"), Spearman's ("s"), and Kendall's ("k") methods.
# 	    The last two methods which are Spearman's and Kendall's coefficient
# are based on the non-parametric analysis.
#	    Default is "p".
#
# na.rm: If na.rm is T, then all the missing samples are deleted from the
# whole dataset, which is (x,y,z).
#        If not, the missing samples will be removed just when the
# correlation coefficient is calculated.
#	   However, the number of samples for the p-value is the number of
# samples after removing
#	   all the missing samples from the whole dataset.
#	   Default is "T".
print("HELLO!")
x <- c(x)
y <- c(y)
z <- as.data.frame(z, check.names = FALSE)
#print(head(x))
#print(head(y))
#print(head(z))
useOk <- TRUE
methodOk <- TRUE
# print the method
if (gregexpr("p", calc_method)[[1]][1] == 1){
p.method <- "Pearson"
} else if (gregexpr("s", calc_method)[[1]][1] == 1){
p.method <- "Spearman"
}else if (gregexpr("k", calc_method)[[1]][1] == 1){
p.method <- "Kendall"
}else{
message("\'method\' should be \"pearson\" or \"spearman\" or \"kendall\"!\n")
methodOk <- FALSE
}
if(methodOk)
{
if (use == "mat") {
p.use <- "Var-Cov matrix"
pcor <- pcor.mat(x, y, z, cor_method = calc_method, na.rm = na.rm)
} else if (use == "rec") {
p.use <- "Recursive formula"
pcor <- pcor.rec(x, y, z, cor_method = calc_method, na.rm = na.rm)
} else {
message("\'use\' should be either \"rec\" or \"mat\"!\n")
useOk <- FALSE
}
}
if(useOk && methodOk)
{
# sample number
n <- dim(na.omit(data.frame(x, y, z, check.names = FALSE)))[1]
# given variables' number
gn <- dim(z)[2]
if (p.method == "Kendall"){
statistic <- pcor / sqrt(2 * (2 * (n - gn) + 5) / (9 * (n - gn) *
(n - 1 - gn)))
p.value <- 2 * pnorm(-abs(statistic))
} else {
val_to_sqrt_l <- n - 2 - gn
val_to_sqrt_r <- 1 - pcor ^ 2
statistic <- pcor * sqrt(val_to_sqrt_l / val_to_sqrt_r)
p.value <- 2 * pnorm(-abs(statistic))
}
#data.frame(estimate = pcor, p.value = p.value, statistic = statistic,
#           n = n, gn = gn, Method = p.method, Use = p.use,
#           check.names = FALSE)
data.frame(estimate = pcor, p.value = p.value)
}
}
map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s"))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
pcor.test2 <- function(y, x, z, use = "mat", calc_method ="p", na.rm = TRUE) {
# The partial correlation coefficient between x and y given z
#
# pcor.test is free and comes with ABSOLUTELY NO WARRANTY.
#
# x and y should be vectors
#
# z can be either a vector or a matrix
#
# use: There are two methods to calculate the partial correlation coefficient
#	 One is by using variance-covariance matrix ("mat") and the other is by
# using recursive formula ("rec").
#	 Default is "mat".
#
# method: There are three ways to calculate the correlation coefficient,
#	which are Pearson's ("p"), Spearman's ("s"), and Kendall's ("k") methods.
# 	    The last two methods which are Spearman's and Kendall's coefficient
# are based on the non-parametric analysis.
#	    Default is "p".
#
# na.rm: If na.rm is T, then all the missing samples are deleted from the
# whole dataset, which is (x,y,z).
#        If not, the missing samples will be removed just when the
# correlation coefficient is calculated.
#	   However, the number of samples for the p-value is the number of
# samples after removing
#	   all the missing samples from the whole dataset.
#	   Default is "T".
x <- c(x)
y <- c(y)
z <- as.data.frame(z, check.names = FALSE)
#print(head(x))
#print(head(y))
#print(head(z))
useOk <- TRUE
methodOk <- TRUE
# print the method
if (gregexpr("p", calc_method)[[1]][1] == 1){
p.method <- "Pearson"
} else if (gregexpr("s", calc_method)[[1]][1] == 1){
p.method <- "Spearman"
}else if (gregexpr("k", calc_method)[[1]][1] == 1){
p.method <- "Kendall"
}else{
message("\'method\' should be \"pearson\" or \"spearman\" or \"kendall\"!\n")
methodOk <- FALSE
}
if(methodOk)
{
if (use == "mat") {
p.use <- "Var-Cov matrix"
pcor <- pcor.mat(x, y, z, cor_method = calc_method, na.rm = na.rm)
} else if (use == "rec") {
p.use <- "Recursive formula"
pcor <- pcor.rec(x, y, z, cor_method = calc_method, na.rm = na.rm)
} else {
message("\'use\' should be either \"rec\" or \"mat\"!\n")
useOk <- FALSE
}
}
if(useOk && methodOk)
{
# sample number
n <- dim(na.omit(data.frame(x, y, z, check.names = FALSE)))[1]
# given variables' number
gn <- dim(z)[2]
if (p.method == "Kendall"){
statistic <- pcor / sqrt(2 * (2 * (n - gn) + 5) / (9 * (n - gn) *
(n - 1 - gn)))
p.value <- 2 * pnorm(-abs(statistic))
} else {
val_to_sqrt_l <- n - 2 - gn
val_to_sqrt_r <- 1 - pcor ^ 2
statistic <- pcor * sqrt(val_to_sqrt_l / val_to_sqrt_r)
p.value <- 2 * pnorm(-abs(statistic))
}
#data.frame(estimate = pcor, p.value = p.value, statistic = statistic,
#           n = n, gn = gn, Method = p.method, Use = p.use,
#           check.names = FALSE)
data.frame(estimate = pcor, p.value = p.value)
}
}
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter))
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
responses<-as.list(select(lhc_result_file,MEASURES))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, parameter,lhc_result_file, MEASURES)
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter))
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
responses<-as.list(select(lhc_result_file,MEASURES))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter))
head(coeff_data)
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
head(coeff_param_col)
responses<-as.list(select(lhc_result_file,MEASURES))
head(responses)
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter))
head(coeff_data)
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
head(coeff_param_col)
responses<-as.list(select(lhc_result_file,MEASURES))
head(responses)
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter))
print(head(coeff_data))
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
print(head(coeff_param_col))
responses<-as.list(select(lhc_result_file,MEASURES))
print(head(responses))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(PARAMETERS[k]),-one_of(MEASURES))
head(coeff_data)
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, PARAMETERS[k],-one_of(MEASURES))
coeff_param_col
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(PARAMETERS[k]),-one_of(MEASURES))
print(head(coeff_data))
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
print(head(coeff_param_col))
responses<-as.list(select(lhc_result_file,MEASURES))
print(head(responses))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter),-one_of(MEASURES))
print(head(coeff_data))
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
print(head(coeff_param_col))
responses<-as.list(select(lhc_result_file,MEASURES))
print(head(responses))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
prccs_for_parameter<-function(parameter,lhc_result_file, MEASURES) {
#print(parameter)
# Get coefficient set
## Replaced by call to select
#COEFFDATA <- lhc_constructcoeff_dataset(LHCRESULTFILE, PARAMETERS[k], PARAMETERS)
coeff_data <- select(lhc_result_file,-one_of(parameter),-one_of(MEASURES))
#print(head(coeff_data))
# Retrieve parameter result
# Replaced by call to select
#COEFFPARAMCOL <- as.numeric(LHCRESULTFILE[, PARAMETERS[k]])
coeff_param_col <- select(lhc_result_file, parameter)
#print(head(coeff_param_col))
responses<-as.list(select(lhc_result_file,MEASURES))
#print(head(responses))
unlist(map(responses, pcor.test2, coeff_param_col, coeff_data, calc_method=c("s")))
}
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES)
unlist(map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES))
map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES) %>% setNames(PARAMETERS)
unlist(all_prccs)
all_prccs <- map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES) %>% setNames(PARAMETERS)
unlist(all_prccs)
unlist(all_prccs,recursive=FALSE)
do.call(c,unlist(all_prccs,recursive=FALSE))
do.call(c,unlist(all_prccs))
as.data.frame(all_prccs)
as_data_frame(all_prccs)
b<-as_data_frame(all_prccs)
b[Velocity.estimate,]
b["Velocity.estimate",]
b["Displacement.estimate",]
b[1,]
rownames(b)
return(as_data_frame(all_prccs,row.names<-row.names(all_prccs)))
as_data_frame(all_prccs,row.names<-row.names(all_prccs))
?as_data_frame
as_data_frame(all_prccs,var="rowname")
b<-as_data_frame(all_prccs,var="rowname")
b["Velocity_estimate"]
b["Velocity_estimate",]
as_data_frame(all_prccs,rownames_to_column())
as_data_frame(all_prccs,rownames_to_column(all_prccs))
data_frame(all_prccs)
as_data_frame(all_prccs)
all_prccs <- map(PARAMETERS, prccs_for_parameter, lhc_result_file, MEASURES) %>% setNames(PARAMETERS)
all_prccs
transpose(all_prccs)
as_data_frame(transpose(all_prccs))
as_data_frame(all_prccs)
as.data.frame(all_prccs)
row_names(as.data.frame(all_prccs))
rownames(as.data.frame(all_prccs))
b<-as.data.frame(all_prccs)
b["Velocity.estimate",]
cor_coefficients<-b
coefficients<-cor_coefficients
coefficients
pull(coefficients,"Velocity,estimate")
pull(coefficients,"Velocity.estimate")
filter(coefficients,-one_of("Velocity.estimate"))
filter(coefficients,one_of("Velocity.estimate"))
rownames_to_column(coefficients,'response')
coefficients<-rownames_to_column(coefficients,'response')
filter(coefficients,response="Velocity.estimate")
filter(coefficients,response=="Velocity.estimate")
coefficients
names(coefficients)
filter(coefficients,"response"=="Velocity.estimate")
coefficients["Velocity.estimate",]
coefficients<-b
coefficients["Velocity.estimate",]
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate")]),make_lhc_plot, measure)
}
lhcresult<-lhc_result_file
# Get data into format where each parameter value is paired with responses
graph_data<-lapply(lhcresult[PARAMETERS], function(x,y){bind_cols(as_data_frame(x),as_data_frame(y))}, lhcresult[MEASURES])
graph_data
cor_coefficients<-b
cor_coefficients
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
measures<-MEASURES
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
parameters<-parameters
parameters<-PARAMETERS
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate")]),make_lhc_plot, measure)
}
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure)
}
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
devtools::load_all(".")
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
print(coefficients)
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure)
}
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
print(coefficients)
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure)
}
devtools::load_all(".")
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
message(coefficients)
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure)
}
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
message(coefficients)
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure)
}
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
coefficients
measures
measure
measure<-"Velocity"
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients)
{
message(paste0("Producing plots for response ",measure))
message(measure)
pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure)
}
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
devtools::load_all(".")
# Now we can make the plot pairings
walk(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
# Now we can make the plot pairings
map(measures,make_graphs,iterate_results_for_plotting, parameters, cor_coefficients)
coefficients[paste0(measure,".estimate"),]
