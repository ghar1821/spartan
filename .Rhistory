ALLRESULTS[, 1]
p <- ggplot(ALLRESULTS[,MEASURE+1], aes(x=ALLRESULTS[,MEASURE+1], y=ALLRESULTS[, 1])) +
geom_boxplot()
library(ggplot2)
p <- ggplot(ALLRESULTS[,MEASURE+1], aes(x=ALLRESULTS[,MEASURE+1], y=ALLRESULTS[, 1])) +
geom_boxplot()
head(ALL_RESULTS)
head(ALLRESULTS)
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,MEASURE+1], y=ALLRESULTS[, 1])) +
geom_boxplot()
p
ALLRESULTS[,MEASURE+1]
ALLRESULTS[, 1]
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot()
p
head(ALLRESULTS)
ALLRESULTS$chemoLowerLinearAdjust<-as.factor(ALLRESULTS$chemoLowerLinearAdjust)
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot()
p
GRAPHTITLE <- paste("Distribution of ", MEASURES[MEASURE],
" Responses \n when altering parameter ",
PARAMETERS[PARAM], sep = "")
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Dose (mg)", y = "Length")+
theme_classic()
p
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Dose (mg)", y = "Length")+
theme(plot.title = element_text(hjust = 0.5))
p
MEASURE_SCALE<-c("microns/min","microns")
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value", y = YLABEL)+
theme(plot.title = element_text(hjust = 0.5))
YLABEL <- paste("Median ", MEASURES[MEASURE], " (",
MEASURE_SCALE[PARAM], ")", sep = "")
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value", y = YLABEL)+
theme(plot.title = element_text(hjust = 0.5))
p
paste0("Hello","Simon")
p <- ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value",
y = paste0("Median ", MEASURES[MEASURE], " (",MEASURE_SCALE[PARAM], ")")) +
theme(plot.title = element_text(hjust = 0.5))
p
ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value",
y = paste0("Median ", MEASURES[MEASURE], " (",MEASURE_SCALE[PARAM], ")")) +
theme(plot.title = element_text(hjust = 0.5))
FILEPATH<-"C:/Users/kja505/Desktop"
ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value",
y = paste0("Median ", MEASURES[MEASURE], " (",MEASURE_SCALE[PARAM], ")")) +
theme(plot.title = element_text(hjust = 0.5))
ggsave(file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"BP.pdf")))
output_types<-c("pdf","png")
for(output in output_types)
{
ggsave(file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"BP.",output)))
}
ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value",
y = paste0("Median ", MEASURES[MEASURE], " (",MEASURE_SCALE[PARAM], ")")) +
theme(plot.title = element_text(hjust = 0.5))
for(output in output_types)
{
ggsave(file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"BP.",output)))
message(paste0("Box Plots Generated and output as ",
file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"BP.",output))))
}
TIMEPOINTS<-NULL
ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value",
y = paste0("Median ", MEASURES[MEASURE], " (",MEASURE_SCALE[PARAM], ")")) +
theme(plot.title = element_text(hjust = 0.5))
for(output in output_types)
{
ggsave(file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"_",TIMEPOINTS,"BP.",output)))
message(paste0("Box Plots Generated and output as ",
file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"BP.",output))))
}
ggplot(ALLRESULTS, aes(x=ALLRESULTS[,1], y=ALLRESULTS[, MEASURE+1])) +
geom_boxplot() + labs(title=GRAPHTITLE,x="Parameter Value",
y = paste0("Median ", MEASURES[MEASURE], " (",MEASURE_SCALE[PARAM], ")")) +
theme(plot.title = element_text(hjust = 0.5))
for(output in output_types)
{
ggsave(file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"_",TIMEPOINTS,"BP.",output)))
message(paste0("Box Plots Generated and output as ",
file.path(FILEPATH,paste0(PARAMETERS[PARAM],MEASURES[MEASURE],"_",TIMEPOINTS,"BP.",output))))
}
devtools::load_all(".")
load("file:///C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PARAMETERS.Rda")
load("C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PARAMETERS.Rda")
load("C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PMIN.Rda")
load("C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PMAX.Rda")
PMAX
NUMCURVES<-5
NUMSAMPLES<-127
wanted_n <- NUMSAMPLES * length(PARAMETERS) * NUMCURVES # wanted no. of sample points
MI <- 4  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
PARAMETERVALS
length(PARAMETERS)
PARAMNUM<-1
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
OM <- array(0, dim = c(1, length(PARAMETERS), 1))
# Loop over the NUMCURVES search curves.
for (CURVENUM in 1:NUMCURVES) {
# Setting the vector of frequencies OM
# for the k parameters
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
# Setting the relation between the scalar
# variable S and the coordinates
# {X(1),X(2),...X(k)} of each sample point.
FI <- array(runif(length(PARAMETERS), min = 0, max = 1),
dim = c(length(PARAMETERS), 1, 1))
FI <- FI * 2 * pi
S_VEC <- pi * (2 * (1:NUMSAMPLES) - NUMSAMPLES - 1) / NUMSAMPLES
OM_VEC <- OM[1:length(PARAMETERS)]
FI_MAT <- array(0, dim = c(length(PARAMETERS), NUMSAMPLES, 1))
for (i in 1:NUMSAMPLES) {
FI_MAT[, i, 1] <- FI
}
# FORMULA IN ORIGINAL MATLAB CODE:
#ANGLE = OM_VEC'*S_VEC+FI_MAT;
# CONVERSION TO R:
om_vec_svec <- array(OM_VEC %*% t(S_VEC),
dim = c(length(PARAMETERS), NUMSAMPLES, 1))
ANGLE <- om_vec_svec + FI_MAT
# TRANSPOSE ARRAY
ANGLET <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS), 1))
for (i in 1:NUMSAMPLES) {
ANGLET[i, , 1] <- ANGLE[, i, 1]
}
# NOW CALCULATE THE PARAMETER VALUES - THESE ARE STORED IN A
# MULTIDIMENSIONAL ARRAY, AS EACH CURVE HAS SEVEN SETS OF PARAMETER
# VALUES
PARAMETERVALS[, , PARAMNUM, CURVENUM] <- 0.5 + asin(sin(ANGLET)) / pi
# AS THESE VALUES WILL CURRENTLY BE BETWEEN 0 AND 1, TRANSFORM THE
# DISTRIBUTION TO GIVE TRUE PARAMETER VALUES
PARAMETERVALS[, , PARAMNUM, CURVENUM] <- efast_parameterdist(
PARAMETERVALS[, , PARAMNUM, CURVENUM], PMAX, PMIN, NUMSAMPLES,
length(PARAMETERS))
}
PARAMETERVALS
PARAMNUM<-2
# Algorithm for selecting the set of frequencies.
# omci(i), i=1:k-1, contains the set of frequencies
# to be used by the complementary group.
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
OM <- array(0, dim = c(1, length(PARAMETERS), 1))
# Loop over the NUMCURVES search curves.
for (CURVENUM in 1:NUMCURVES) {
# Setting the vector of frequencies OM
# for the k parameters
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
# Setting the relation between the scalar
# variable S and the coordinates
# {X(1),X(2),...X(k)} of each sample point.
FI <- array(runif(length(PARAMETERS), min = 0, max = 1),
dim = c(length(PARAMETERS), 1, 1))
FI <- FI * 2 * pi
S_VEC <- pi * (2 * (1:NUMSAMPLES) - NUMSAMPLES - 1) / NUMSAMPLES
OM_VEC <- OM[1:length(PARAMETERS)]
FI_MAT <- array(0, dim = c(length(PARAMETERS), NUMSAMPLES, 1))
for (i in 1:NUMSAMPLES) {
FI_MAT[, i, 1] <- FI
}
# FORMULA IN ORIGINAL MATLAB CODE:
#ANGLE = OM_VEC'*S_VEC+FI_MAT;
# CONVERSION TO R:
om_vec_svec <- array(OM_VEC %*% t(S_VEC),
dim = c(length(PARAMETERS), NUMSAMPLES, 1))
ANGLE <- om_vec_svec + FI_MAT
# TRANSPOSE ARRAY
ANGLET <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS), 1))
for (i in 1:NUMSAMPLES) {
ANGLET[i, , 1] <- ANGLE[, i, 1]
}
# NOW CALCULATE THE PARAMETER VALUES - THESE ARE STORED IN A
# MULTIDIMENSIONAL ARRAY, AS EACH CURVE HAS SEVEN SETS OF PARAMETER
# VALUES
PARAMETERVALS[, , PARAMNUM, CURVENUM] <- 0.5 + asin(sin(ANGLET)) / pi
# AS THESE VALUES WILL CURRENTLY BE BETWEEN 0 AND 1, TRANSFORM THE
# DISTRIBUTION TO GIVE TRUE PARAMETER VALUES
PARAMETERVALS[, , PARAMNUM, CURVENUM] <- efast_parameterdist(
PARAMETERVALS[, , PARAMNUM, CURVENUM], PMAX, PMIN, NUMSAMPLES,
length(PARAMETERS))
}
PARAMETERVALS
CURVENUM<-65
NUMSAMPLES<-65
NUMCURVES<-1
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
MI <- 4  # maximum number of fourier coefficients
# that may be retained in calculating the partial
# variances without interferences between the
# assigned frequencies
# Computation of the frequency for the group
# of interest omi and the # of sample points NUMSAMPLES (here N=NUMSAMPLES)
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
NUMSAMPLES <- 2 * MI * omi + 1
if (NUMSAMPLES * NUMCURVES < 65)
message("Error: sample size must be >= 65 per factor")
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
PARAMNUM<-1
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
OM <- array(0, dim = c(1, length(PARAMETERS), 1))
# Loop over the NUMCURVES search curves.
for (CURVENUM in 1:NUMCURVES) {
# Setting the vector of frequencies OM
# for the k parameters
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
# Setting the relation between the scalar
# variable S and the coordinates
# {X(1),X(2),...X(k)} of each sample point.
FI <- array(runif(length(PARAMETERS), min = 0, max = 1),
dim = c(length(PARAMETERS), 1, 1))
FI <- FI * 2 * pi
S_VEC <- pi * (2 * (1:NUMSAMPLES) - NUMSAMPLES - 1) / NUMSAMPLES
OM_VEC <- OM[1:length(PARAMETERS)]
FI_MAT <- array(0, dim = c(length(PARAMETERS), NUMSAMPLES, 1))
for (i in 1:NUMSAMPLES) {
FI_MAT[, i, 1] <- FI
}
# FORMULA IN ORIGINAL MATLAB CODE:
#ANGLE = OM_VEC'*S_VEC+FI_MAT;
# CONVERSION TO R:
om_vec_svec <- array(OM_VEC %*% t(S_VEC),
dim = c(length(PARAMETERS), NUMSAMPLES, 1))
ANGLE <- om_vec_svec + FI_MAT
# TRANSPOSE ARRAY
ANGLET <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS), 1))
for (i in 1:NUMSAMPLES) {
ANGLET[i, , 1] <- ANGLE[, i, 1]
}
# NOW CALCULATE THE PARAMETER VALUES - THESE ARE STORED IN A
# MULTIDIMENSIONAL ARRAY, AS EACH CURVE HAS SEVEN SETS OF PARAMETER
# VALUES
PARAMETERVALS[, , PARAMNUM, CURVENUM] <- 0.5 + asin(sin(ANGLET)) / pi
# AS THESE VALUES WILL CURRENTLY BE BETWEEN 0 AND 1, TRANSFORM THE
# DISTRIBUTION TO GIVE TRUE PARAMETER VALUES
PARAMETERVALS[, , PARAMNUM, CURVENUM] <- efast_parameterdist(
PARAMETERVALS[, , PARAMNUM, CURVENUM], PMAX, PMIN, NUMSAMPLES,
length(PARAMETERS))
}
PARAMETERVALS
MI <- 4  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
PARAMNUM<-1
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
OM <- array(0, dim = c(1, length(PARAMETERS), 1))
CURVENUM<-1
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
FI <- array(runif(length(PARAMETERS), min = 0, max = 1),
dim = c(length(PARAMETERS), 1, 1))
FI
FI <- FI * 2 * pi
S_VEC <- pi * (2 * (1:NUMSAMPLES) - NUMSAMPLES - 1) / NUMSAMPLES
OM_VEC <- OM[1:length(PARAMETERS)]
FI_MAT <- array(0, dim = c(length(PARAMETERS), NUMSAMPLES, 1))
for (i in 1:NUMSAMPLES) {
FI_MAT[, i, 1] <- FI
}
FI_MAY
FI_MAT
om_vec_svec <- array(OM_VEC %*% t(S_VEC),
dim = c(length(PARAMETERS), NUMSAMPLES, 1))
ANGLE <- om_vec_svec + FI_MAT
ANGLET <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS), 1))
for (i in 1:NUMSAMPLES) {
ANGLET[i, , 1] <- ANGLE[, i, 1]
}
ANGLET
om_vec_svec <- array(OM_VEC %*% t(S_VEC),
dim = c(length(PARAMETERS), NUMSAMPLES, 1))
ANGLE <- om_vec_svec + FI_MAT
ANGLE
ANGLET <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS), 1))
ANGLET
ANGLE
NUMSAMPLES
ANGLE[,633]
ANGLE
dim(ANGLE)
ANGLE[,633,1]
ANGLE
om_vec_svec
FI_MAT
ANGLE <- om_vec_svec + FI_MAT
ANGLE
ANGLE
dim(ANGLE)
ANGLE[1,633,1]
ANGLE[1,633,]
ANGLE[,633,1]
ANGLE[2,633,1]
om_vec_svec
dim(om_vec_svec)
om_vec_svec[,633,1]
FI_MAT
dim(FI_MAT)
FI_MAT[,633,1]
OM_VEC
S_VEC
length(PARAMETERS)
OM[1:length(PARAMETERS)]
1:length(PARAMETERS)
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
OM
j<-11
OM[j] <- omci[cj]
omci[cj]
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
omci
omi
omi / 2 / MI
wanted_n <- NUMSAMPLES * length(PARAMETERS) * NUMCURVES # wanted no. of sample points
wanted_n
NUMSAMPLES<-127
wanted_n <- NUMSAMPLES * length(PARAMETERS) * NUMCURVES # wanted no. of sample points
wanted_n
MI <- 4  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
omi
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
omci
NUMCURVES
omi
omi / 2 / MI
MI <- 2  # maximum number of fourier coefficients
NUMCURVES<-3
NUMSAMPLES<-127
wanted_n <- NUMSAMPLES * length(PARAMETERS) * NUMCURVES # wanted no. of sample points
MI <- 2  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
PARAMNUM<-1
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
omci
omi / 2 / MI
MI <- 6  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
omci
omi
wanted_n
NUMCURVES
MI
omi / 2 / MI
wanted_n <- NUMSAMPLES * length(PARAMETERS) * NUMCURVES # wanted no. of sample points
MI <- 4  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
omci <- efast_setfreq(length(PARAMETERS), omi / MI, PARAMNUM)
omci
omi / MI,
omi / MI
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
omi
omci <- efast_setfreq(length(PARAMETERS), length(PARAMETERS), PARAMNUM)
omci
OM <- array(0, dim = c(1, length(PARAMETERS), 1))
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
OM
omi
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
omi
MI
omi <- floor(((wanted_n / NUMCURVES)) / (2 * MI) / length(PARAMETERS))
omi
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / length(PARAMETERS))
omi
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / (length(PARAMETERS)/3))
omi
NUMSAMPLES<-127
NUMCURVES<-5
wanted_n <- NUMSAMPLES * length(PARAMETERS) * NUMCURVES # wanted no. of sample points
MI <- 4  # maximum number of fourier coefficients
omi <- floor(((wanted_n / NUMCURVES) - 1) / (2 * MI) / (length(PARAMETERS)/3))
omi
NUMSAMPLES <- 2 * MI * omi + 1
PARAMETERVALS <- array(0, dim = c(NUMSAMPLES, length(PARAMETERS),
length(PARAMETERS), NUMCURVES))
PARAMNUM<-1
omci <- efast_setfreq(length(PARAMETERS), omi / 2 / MI, PARAMNUM)
omci
omci <- efast_setfreq(length(PARAMETERS), length(PARAMETERS), PARAMNUM)
omci <- efast_setfreq(length(PARAMETERS), length(PARAMETERS), PARAMNUM)
omci
cj <- 1
for (j in 1:length(PARAMETERS)) {
if (j == PARAMNUM) {
# For the parameter (factor) of interest
# RECODE WHEN WORKED OUT OM ARRAY
OM[PARAMNUM] <- omi
} else {
# For the complementary group.
# RECODE WHEN WORKED OUT ARRAY
OM[j] <- omci[cj]
cj <- cj + 1
}
}
OM
rm(list=ls())
devtools::load_all(".")
load("C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PARAMETERS.Rda")
load("C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PMIN.Rda")
load("C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/PMAX.Rda")
FILEPATH<-"C:/Users/kja505/Desktop/kieran_eFAST/kieran_eFAST/"
NUMCURVES<-5
NUMSAMPLES<-127
input_check <- list("arguments"=as.list(match.call()),"names"=names(match.call())[-1])
parameter_vals <- generate_efast_parameter_sets(FILEPATH, NUMCURVES,
NUMSAMPLES, PARAMETERS,
PMIN, PMAX)
output_param_sets_per_curve(FILEPATH, NUMCURVES, PARAMETERS, parameter_vals)
devtools::build()
efast_generate_sample(FILEPATH,NUMCURVES,NUMSAMPLES,PARAMETERS,PMIN,PMAX)
